## 141、环形链表

两种思路：  
1、利用 hashSet 的唯一性，将每个节点存入其中，判断是否已存在；  
2、设置快慢指针（慢指针每次指向下一个节点，快指针每次指向下下个节点），
看二者是否会相遇。

实际上如果是环形链表，循环永远不会走到头（因为没有），但不排除很长的单向链表。因此需要在循环里作判断。
不管是用快慢指针判断是否会相遇，还是放入 hashSet 中判断是否已存在。

## 203、移除链表元素

返回的不是原链表，而是一个新的链表。   
因此遍历原链表的元素，将每个元素与指定要删的值进行比较。   
若不是要删的值，则添加到新链表中，新链表默认初始值为空（不为空也可以，返回的时候直接返回 .next）   
关键在于最后要返回完整的新链表，因此需要创建两个指针，一个指向头节点，另一个随着链表添加元素向后移动，不断地指向下一个节点。

注意体会链表中指针的意义（其实也是新建一个”链表“）、双指针的用法。

## 160、相交链表

两种思路：   
1、双重循环，注意内部循环完一边后链表指针已到末尾，因此外部循环进入下一次时，内部应该重头开始，所以内部循环要用链表的拷贝。    
2、同时从头移动两个链表的指针，长度一致则直接判断是否相等；长度不一致，短的链表指针先走到末尾，则继续从另一个链表的头开始移动...直到某一点时两个长度相等。

## 21、合并两个有序链表

1、迭代法：  
依旧是双指针，一个指向头节点，另一个向后移动，对给定的两个有序链表的每个节点的值进行比较，注意当一个链表走完后，另一个链表剩下的则直接拼到后面（因为此时剩余节点值一定都大于比较的节点）；   
2、递归法：   
对给定的两个有序链表的每个节点的值进行比较，较小的添加到合并的链表里，然后 .next 继续递归进入下一次比较。
