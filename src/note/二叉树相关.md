## 101、对称二叉树

分别将左右树每个节点的值 val 按顺序添加到对应的 list 中，没有值时添加 null，最后比较 list 是否相等

## 110、平衡二叉树

借鉴求二叉树最大深度，任一节点左右高度差大于 1 时，此二叉树即不为平衡二叉树
（此时可标记常量数组的值为负数最终用来判断）

## 104、二叉树的最大深度

分别递归左右树的高度，取最大值 + 1（每个节点算一层）

## 111、二叉树的最小深度

分三种情况：  
若左右都为空，则最小深度为 1（当前节点）；  
若左右都不为空，则最小深度为 min + 1；  
若只有一边为空，则此时的最小深度即为最大深度 max + 1

## 144&145&94、二叉树的前序遍历（中左右）、后序遍历（左右中）、中序遍历（左中右）
返回的都是 list 数组，按顺序递归，先中间就先添加 val 到 list，先左右就先递归左右节点

## 100、相同的树
还是利用到二叉树的遍历（前序后序中序均可），将两个二叉树分别遍历存到 list 中，
比较 list 是否相等。
与对称二叉树类似，只不过对称二叉树是比较一个根节点的左右树，因此需要注意添加到
list 中的顺序要相反。

## 226、翻转二叉树
每次递归将左右节点互换，再进入下一次递归（先左后右）

## 257、二叉树的所有路径
1、递归获取所有叶子节点添加到 list（没有子节点的节点）；   
2、每次递归时获取节点的 val 值，用 StringBuilder 进行拼接，注意下一次递归时要new StringBuilder(sb)；  
3、当递归到叶子节点时（即没有左右节点），将拼接的 sb 添加到 list 中